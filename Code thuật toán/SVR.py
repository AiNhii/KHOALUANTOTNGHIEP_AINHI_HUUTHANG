# -*- coding: utf-8 -*-
"""SVR_ETH_Fix_(9).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t9m2e4QDrMBVm5JjRuNTbATGsvqe_dzd
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler, StandardScaler
from numpy import array
import warnings
warnings.filterwarnings('ignore')

from scipy import stats
# %matplotlib inline
import pickle
import tensorflow as tf
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error, r2_score
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
from keras.wrappers.scikit_learn import KerasRegressor
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
from sklearn.model_selection import GridSearchCV
from keras.layers import Dense
from keras.layers import Flatten
from keras.layers import TimeDistributed
from keras.layers import ConvLSTM2D
from keras.layers.convolutional import MaxPooling1D
from sklearn.svm import SVR

df = pd.read_csv("/content/drive/MyDrive/dataset/NEW/data/eth.csv", parse_dates=True, index_col="formatted_date")
df.head()

# Process data
df['H-L'] = df['high'] - df['low']
# df['O-C'] = df['open'] - df['close']
ma_1 = 7
ma_2 = 14
ma_3 = 21
df[f'SMA_{ma_1}'] = df['close'].rolling(window=ma_1).mean()
df[f'SMA_{ma_2}'] = df['close'].rolling(window=ma_2).mean()
df[f'SMA_{ma_3}'] = df['close'].rolling(window=ma_3).mean()

df[f'SD_{ma_1}'] = df['close'].rolling(window=ma_1).std()
df[f'SD_{ma_3}'] = df['close'].rolling(window=ma_3).std()
df.dropna(inplace=True)

df.to_csv("bitcoin_processed_7_3.csv")
df

pre_day = 7
scala_x = MinMaxScaler(feature_range=(0,1))
scala_y = MinMaxScaler(feature_range=(0,1))
cols_x = ['high', 'low', 'open', 'H-L', f'SMA_{ma_1}', f'SMA_{ma_2}', f'SMA_{ma_3}', f'SD_{ma_1}', f'SD_{ma_3}']
cols_y = ['close']
scaled_data_x = scala_x.fit_transform(df[cols_x].values)
scaled_data_y = scala_y.fit_transform(df[cols_y].values)

x_total = []
y_total = []

for i in range(pre_day, len(df)):
    x_total.append(scaled_data_x[i-pre_day:i])
    y_total.append(scaled_data_y[i])

test_size = (int)(len(scaled_data_y) * 0.2)
print(test_size)

x_train = np.array(x_total[:len(x_total)-test_size])
x_test = np.array(x_total[len(x_total)-test_size:])
y_train = np.array(y_total[:len(y_total)-test_size])
y_test = np.array(y_total[len(y_total)-test_size:])



print(x_train.shape, y_train.shape, x_test.shape, y_test.shape)

#n_steps = 3
#n_features = 1
#n_seq = 2

n_steps, n_features = x_train.shape[1], x_train.shape[2]
x_train = x_train.reshape((x_train.shape[0], 1, 1, n_steps, n_features))
x_test = x_test.reshape((x_test.shape[0], 1, 1, n_steps, n_features))

# kernels = ('sigmoid', 'rbf', 'poly', 'linear')
# Cs =[0.1, 1, 10]
# gammas = [0.01, 0.05, 0.1]
# degrees = [1, 2, 3, 4]
# eps = [0.1, 0.2, 0.3]
# params = {'kernel' : kernels, 'C' : Cs, 'gamma' : gammas, 'degree' : degrees, 'epsilon' : eps}
model = SVR()
params = {
    'kernel': ['sigmoid', 'rbf', 'poly', 'linear'],
    'C': [0.1, 1, 10],
    'gamma': ['scale', 'auto']
}

grid = GridSearchCV(estimator=model, param_grid=params, cv=5, n_jobs=-1)
grid.fit(x_train.reshape(x_train.shape[0], -1), y_train)

grid.best_estimator_

grid.best_params_

y_pred = grid.predict(x_train.reshape(x_train.shape[0], -1))

x_test_reshaped = x_test.reshape(x_test.shape[0], -1)

# x_test_reshaped = x_test.reshape(-1, x_test.shape[-1])

# Dự đoán giá
y_pred = grid.predict(x_test_reshaped)

# Đưa kết quả về lại đơn vị ban đầu
y_pred_reshaped = y_pred.reshape(-1, 1)
y_pred_original = scala_y.inverse_transform(y_pred_reshaped)
# y_pred = scala_y.inverse_transform(y_pred)

# Ploting the stat
real_price = df[len(df)-test_size:]['close'].values.reshape(-1,1)
real_price = np.array(real_price)
print(real_price.shape)
real_price = real_price.reshape(real_price.shape[0], 1)

plt.figure(figsize=(16,9))
plt.grid(True)
plt.plot(real_price, color="red", label=f"Real BTC Prices")
plt.plot(y_pred_original, color="blue", label=f"Predicted BTC Prices")
plt.title(f"ETH Prices")
plt.xlabel("Time (day)")
plt.ylabel("Stock Prices")
plt.ylim(bottom=0)
plt.legend()
plt.show()

# Make Prediction
x_predict = df[len(df)-pre_day:][cols_x].values.reshape(-1, len(cols_x))
x_predict = scala_x.transform(x_predict)
x_predict = np.array(x_predict)
x_predict = x_predict.reshape(1,1,1, x_predict.shape[0], len(cols_x))


x_predict_reshaped = x_predict.reshape(x_predict.shape[0], -1)

prediction = grid.predict(x_predict_reshaped)
prediction_reshaped = prediction.reshape(-1, 1)
prediction = scala_y.inverse_transform(prediction_reshaped)
print(prediction)

mae = mean_absolute_error(real_price, y_pred_original)
mape = mean_absolute_percentage_error(real_price, y_pred_original)
mse = mean_squared_error(real_price, y_pred_original)
rmse = np.sqrt(mse)
r2 = r2_score(real_price, y_pred_original)

print(f"MAE: {mae:.4f}")
print(f"MAPE: {mape * 100:.4f}%")
print(f"MSE: {mse:.4f}")
print(f"RMSE: {rmse:.4f}")
print(f"R-Squared: {r2*100:.4f}%")
